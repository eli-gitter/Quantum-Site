<!DOCTYPE html>
<html>
<head>
    <title>Quantum Bit Generator</title>
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-lighter.min.css">
    
    <style>
        /* Your existing styles stay the same... */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(135deg, #e8f4fd 0%, #d3cedc 100%);
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Add CodeMirror custom styling */
        .CodeMirror {
            height: 100% !important;
            font-family: 'Courier New', monospace !important;
            font-size: 13px !important;
            border-radius: 8px !important;
            border: 1px solid rgba(214, 231, 255, 0.8) !important;
            background: rgba(255, 255, 255, 0.9) !important;
        }
        
        .CodeMirror-focused .CodeMirror-cursor {
            border-left: 2px solid #5a67d8 !important;
        }
        
        .CodeMirror-selected {
            background: rgba(90, 103, 216, 0.2) !important;
        }
        
        /* Keep all your existing styles... */

        body:active {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto;
        }
        canvas { display: block; }
        
        /* Force atom cursor everywhere except text inputs */
        * {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
        }

        /* Text cursor only for input fields */
        #code-input, textarea {
            cursor: text !important;
        }

        /* Atom cursor for all terminal elements */
        #terminal-container,
        #terminal-header,
        #terminal-body,
        #terminal-output,
        .terminal-buttons,
        .btn,
        .terminal-title,
        #code-container,
        #code-header,
        #code-body {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
        }

        /* Atom cursor for canvas and 3D elements */
        canvas {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
        }
        
        /* Code Input Container */
        #code-container {
            position: absolute;
            left: 50px;
            top: 30px;
            width: 35%;
            height: 45%;
            background: rgba(232, 244, 253, 0.95);
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 8px 32px rgba(138, 143, 244, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            border: 2px solid rgba(200, 216, 240, 0.8);
        }

        #code-header {
            background: linear-gradient(135deg, #d6e7ff 0%, #e1d5f7 100%);
            padding: 12px 18px;
            border-radius: 12px 12px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(200, 216, 240, 0.6);
            box-shadow: 0 2px 8px rgba(138, 143, 244, 0.1);
        }

        .code-title {
            color: #5a67d8;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        #code-body {
            flex: 1;
            padding: 18px;
            background: linear-gradient(135deg, #f7faff 0%, #faf5ff 100%);
            border-radius: 0 0 12px 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #code-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(214, 231, 255, 0.8);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #4a5568;
            resize: none;
            outline: none;
            box-shadow: 0 2px 8px rgba(138, 143, 244, 0.1);
            margin-bottom: 10px;
        }

        #code-input::placeholder {
            color: #a0aec0;
        }

        #run-button {
            background: linear-gradient(135deg, #8b5cf6 0%, #5a67d8 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
            transition: all 0.2s ease;
        }

        #run-button:hover {
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
        }

        /* Terminal Output Container */
        #terminal-container {
            position: absolute;
            left: 50px;
            bottom: 30px;
            width: 35%;
            height: 45%;
            background: rgba(232, 244, 253, 0.95);
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 8px 32px rgba(138, 143, 244, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            border: 2px solid rgba(200, 216, 240, 0.8);
        }

        #terminal-header {
            background: linear-gradient(135deg, #d6e7ff 0%, #e1d5f7 100%);
            padding: 12px 18px;
            border-radius: 12px 12px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(200, 216, 240, 0.6);
            box-shadow: 0 2px 8px rgba(138, 143, 244, 0.1);
        }

        .terminal-buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .terminal-title {
            color: #5a67d8;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        #terminal-body {
            flex: 1;
            padding: 18px;
            background: linear-gradient(135deg, #f7faff 0%, #faf5ff 100%);
            border-radius: 0 0 12px 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #terminal-output {
            flex: 1;
            color: #4a5568;
            font-size: 13px;
            line-height: 1.5;
            overflow-y: auto;
            white-space: pre-wrap;
            background: rgba(255, 255, 255, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: inset 0 2px 4px rgba(138, 143, 244, 0.05);
        }

        /* Enhanced scrollbar styling */
        #terminal-output::-webkit-scrollbar, #code-input::-webkit-scrollbar {
            width: 8px;
        }

        #terminal-output::-webkit-scrollbar-track, #code-input::-webkit-scrollbar-track {
            background: rgba(232, 244, 253, 0.5);
            border-radius: 4px;
        }

        #terminal-output::-webkit-scrollbar-thumb, #code-input::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #c8d8f0 0%, #b794f6 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #terminal-output::-webkit-scrollbar-thumb:hover, #code-input::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #b794f6 0%, #8b5cf6 100%);
        }

        /* Display Panel */
        #display-panel {
            position: absolute;
            right: 50px;
            top: 30px;
            bottom: 30px;
            left: 45%;
            background: rgba(232, 244, 253, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(138, 143, 244, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(200, 216, 240, 0.8);
            display: flex;
            flex-direction: column;
            z-index: 500;
        }

        #display-header {
            background: linear-gradient(135deg, #d6e7ff 0%, #e1d5f7 100%);
            padding: 12px 18px;
            border-radius: 12px 12px 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid rgba(200, 216, 240, 0.6);
            box-shadow: 0 2px 8px rgba(138, 143, 244, 0.1);
        }

        .panel-title {
            color: #5a67d8;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        #display-body {
            flex: 1;
            position: relative;
            overflow: hidden;
            border-radius: 0 0 12px 12px;
            background: linear-gradient(135deg, #f7faff 0%, #faf5ff 100%);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        #welcome-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #5a67d8;
            font-size: 18px;
            font-weight: 300;
            opacity: 0.7;
        }

        #welcome-message .subtitle {
            font-size: 14px;
            margin-top: 10px;
            color: #8b5cf6;
        }

        .CodeMirror-placeholder {
            color: #a0aec0 !important;
            font-style: italic;
        }

    </style>
</head>
<body>
    <!-- Code Input Container -->
    <div id="code-container">
        <div id="code-header">
            <div class="code-title">Qiskit Code Editor</div>
        </div>
        <div id="code-body">
            <div id="code-input"></div>
            <button id="run-button">▶ Run Code</button>
        </div>
    </div>

    <!-- Terminal Output Container -->
    <div id="terminal-container">
        <div id="terminal-header">
            <div class="terminal-title">Output Terminal</div>
        </div>
        <div id="terminal-body">
            <div id="terminal-output"></div>
        </div>
    </div>

    <!-- Display Panel -->
    <div id="display-panel">
        <div id="display-header">
            <div class="code-title">Quantum State Visualization</div>
        </div>
        <div id="display-body">
            <div id="canvas-container">
                <div id="welcome-message">
                    <div>Welcome to Quantum Visualizer</div>
                    <div class="subtitle">Run Qiskit code to see quantum states on the Bloch sphere</div>
                </div>
            </div>
        </div>
    </div>

<!-- Load Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- Add CodeMirror JavaScript -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/display/placeholder.min.js"></script>
    
    <script>
        // Backend API functions
        async function runQiskitCode(code) {
            try {
                const response = await fetch('/api/quantum/execute', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ code: code })
                });
                const data = await response.json();
                
                if (data.success) {
                    addToTerminal(`Code executed successfully`);
                    if (data.output) {
                        addToTerminal(`Output: ${data.output}`);
                    }
                    if (data.quantum_states && data.quantum_states.length > 0) {
                        addToTerminal(`Quantum state updated: x=${data.quantum_states[0].x.toFixed(3)}, y=${data.quantum_states[0].y.toFixed(3)}, z=${data.quantum_states[0].z.toFixed(3)}`);
                        animateArrowTo(data.quantum_states[0]);
                    }
                } else {
                    addToTerminal(`Error: ${data.error}`, true);
                }
            } catch (error) {
                addToTerminal(`Connection error: ${error.message}`, true);
            }
        }

        // Initialize CodeMirror
        const codeEditor = CodeMirror(document.getElementById('code-input'), {
            mode: 'python',
            theme: 'material-lighter',
            lineNumbers: true,
            indentUnit: 4,
            indentWithTabs: false,
            lineWrapping: true,
            value: ``,
            placeholder: `Enter your Qiskit code here`,
            extraKeys: {
                "Ctrl-Enter": function(cm) {
                    runButton.click();
                }
            }
        });

        // Terminal functionality
        const terminalOutput = document.getElementById('terminal-output');
        const runButton = document.getElementById('run-button');

        function addToTerminal(text, isError = false) {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = `[${timestamp}] `;
            const color = isError ? 'color: #e53e3e;' : '';
            terminalOutput.innerHTML += `<span style="${color}">${prefix}${text}</span>\n`;
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        // Run button click handler
        runButton.addEventListener('click', async () => {
            const code = codeEditor.getValue().trim(); // This changed from codeInput.value
            if (code) {
                addToTerminal(`Executing Qiskit code...`);
                await runQiskitCode(code);
            } else {
                addToTerminal('No code to execute', true);
            }
        });

        // THREE.JS BLOCH SPHERE VISUALIZATION
        const scene = new THREE.Scene();

        // Get canvas container dimensions
        const canvasContainer = document.getElementById('canvas-container');
        const containerRect = canvasContainer.getBoundingClientRect();
        const canvasWidth = containerRect.width;
        const canvasHeight = containerRect.height;

        const camera = new THREE.PerspectiveCamera(75, canvasWidth/canvasHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(canvasWidth, canvasHeight);
        renderer.setClearColor(0xf8f9fa, 0.1);
        
        // Add renderer to canvas container instead of body
        canvasContainer.appendChild(renderer.domElement);
        
        // Hide welcome message
        const welcomeMessage = document.getElementById('welcome-message');
        if (welcomeMessage) {
            welcomeMessage.style.display = 'none';
        }

        // Create sphere with enhanced translucent material matching color scheme
        const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xe0e1e3,
            transparent: true, 
            opacity: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Create a group for the equatorial elements
        const equatorialGroup = new THREE.Group();

        // Create equatorial plane (circular disk) with theme colors
        const planeGeometry = new THREE.CircleGeometry(2, 32);
        const planeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xc8d8f0,
            transparent: true, 
            opacity: 0.2,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const equatorialPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        equatorialPlane.rotation.x = Math.PI / 2;

        // Create X axis with theme color
        const xAxisPoints = [
            new THREE.Vector3(-2, 0, 0),
            new THREE.Vector3(2, 0, 0)
        ];
        const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPoints);
        const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0x5a67d8, linewidth: 2 });
        const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);

        // Create Y axis with theme color
        const yAxisPoints = [
            new THREE.Vector3(0, 0, -2),
            new THREE.Vector3(0, 0, 2)
        ];
        const yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPoints);
        const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x5a67d8, linewidth: 2 });
        const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);

        // Add plane and axes to the equatorial group
        equatorialGroup.add(equatorialPlane);
        equatorialGroup.add(xAxis);
        equatorialGroup.add(yAxis);
        scene.add(equatorialGroup);

        function createTextTexture(text, color = '#5a67d8') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = color;
            context.font = 'bold 40px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'alphabetic';
            context.fillText(text, 256, 168);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        // Create labels
        const oneTexture = createTextTexture('|1⟩', '#5a67d8');
        const oneMaterial = new THREE.SpriteMaterial({ 
            map: oneTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const oneLabel = new THREE.Sprite(oneMaterial);
        oneLabel.position.set(0, 2.3, 0);
        oneLabel.scale.set(0.5, 0.25, 1);

        const zeroTexture = createTextTexture('|0⟩', '#5a67d8');
        const zeroMaterial = new THREE.SpriteMaterial({ 
            map: zeroTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const zeroLabel = new THREE.Sprite(zeroMaterial);
        zeroLabel.position.set(0, -2.10, 0);
        zeroLabel.scale.set(0.5, 0.25, 1);

        const xTexture = createTextTexture('X', '#5a67d8');
        const xMaterial = new THREE.SpriteMaterial({ 
            map: xTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const xLabel = new THREE.Sprite(xMaterial);
        xLabel.position.set(2.2, 0.1, 0);
        xLabel.scale.set(0.5, 0.25, 1);

        const yTexture = createTextTexture('Y', '#5a67d8');
        const yMaterial = new THREE.SpriteMaterial({ 
            map: yTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const yLabel = new THREE.Sprite(yMaterial);
        yLabel.position.set(0, 0.1, -2.2);
        yLabel.scale.set(0.5, 0.25, 1);

        // Add labels to a group
        const labelGroup = new THREE.Group();
        labelGroup.add(oneLabel);
        labelGroup.add(zeroLabel);
        labelGroup.add(xLabel);
        labelGroup.add(yLabel);
        scene.add(labelGroup);

        // Create arrow components
        const redSphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
        const redSphereMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 });
        const redSphere = new THREE.Mesh(redSphereGeometry, redSphereMaterial);

        const arrowGroup = new THREE.Group();

        const arrowPoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 1.95, 0)
        ];
        const arrowGeometry = new THREE.BufferGeometry().setFromPoints(arrowPoints);
        const arrowMaterial = new THREE.LineBasicMaterial({ color: 0x8b5cf6, linewidth: 3 });
        const arrowShaft = new THREE.Line(arrowGeometry, arrowMaterial);

        const coneGeometry = new THREE.ConeGeometry(0.05, 0.15, 20);
        const coneMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 });
        const arrowTip = new THREE.Mesh(coneGeometry, coneMaterial);
        arrowTip.position.y = 1.93;

        arrowGroup.add(arrowShaft);
        arrowGroup.add(arrowTip);
        arrowGroup.add(redSphere);
        scene.add(arrowGroup);

        // Add latitude and longitude lines
        const lineGroup = new THREE.Group();
        
        // Latitude lines
        for (let i = 0; i <= 10; i++) {
            const phi = (i / 10) * Math.PI;
            const points = [];
            for (let j = 0; j <= 64; j++) {
                const theta = (j / 64) * Math.PI * 2;
                const x = 2 * Math.sin(phi) * Math.cos(theta);
                const y = 2 * Math.cos(phi);
                const z = 2 * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xc8d8f0,
                opacity: 0.4, 
                transparent: true 
            });
            const line = new THREE.Line(geometry, material);
            lineGroup.add(line);
        }

        // Longitude lines
        for (let i = 0; i < 12; i++) {
            const theta = (i / 12) * Math.PI * 2;
            const points = [];
            for (let j = 0; j <= 32; j++) {
                const phi = (j / 32) * Math.PI;
                const x = 2 * Math.sin(phi) * Math.cos(theta);
                const y = 2 * Math.cos(phi);
                const z = 2 * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xc8d8f0,
                opacity: 0.4, 
                transparent: true 
            });
            const line = new THREE.Line(geometry, material);
            lineGroup.add(line);
        }

        scene.add(lineGroup);
        camera.position.z = 5;

        // Mouse controls for rotation - only when clicking on sphere
        let isMouseDown = false;
        let isRotatingAllowed = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;

        // Raycaster for detecting sphere clicks
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function updateMousePosition(event) {
            // Calculate mouse position relative to the canvas
            const canvasRect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
            mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;
        }

        function isClickOnSphere(event) {
            updateMousePosition(event);
            
            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections with the sphere
            const intersects = raycaster.intersectObject(sphere);
            
            return intersects.length > 0;
        }

        document.addEventListener('mousedown', (event) => {
            // Only allow rotation if clicking on the sphere
            if (isClickOnSphere(event)) {
                isMouseDown = true;
                isRotatingAllowed = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
                
                // Optional: Change cursor to indicate dragging
                document.body.style.cursor = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="2"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="2"/></svg>\') 10 10, auto';
            }
        });

document.addEventListener('mouseup', () => {
            isMouseDown = false;
            isRotatingAllowed = false;
            
            // Reset cursor
            document.body.style.cursor = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>\') 10 10, auto';
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown && isRotatingAllowed) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        // Update touch controls similarly
        let touchX = 0, touchY = 0;
        let isTouchRotatingAllowed = false;

        function isTouchOnSphere(event) {
            if (event.touches.length !== 1) return false;
            
            const canvasRect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.touches[0].clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
            mouse.y = -((event.touches[0].clientY - canvasRect.top) / canvasRect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(sphere);
            
            return intersects.length > 0;
        }

        function handleTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isTouchOnSphere(event)) {
                isTouchRotatingAllowed = true;
                touchX = event.touches[0].clientX;
                touchY = event.touches[0].clientY;
            }
        }

        function handleTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isTouchRotatingAllowed) {
                const deltaX = event.touches[0].clientX - touchX;
                const deltaY = event.touches[0].clientY - touchY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                
                touchX = event.touches[0].clientX;
                touchY = event.touches[0].clientY;
            }
        }

        function handleTouchEnd(event) {
            event.preventDefault();
            isTouchRotatingAllowed = false;
        }

        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Animation functions
        function animateArrowTo(targetState) {
            const duration = 1000;
            const startTime = Date.now();
            
            // Get current arrow direction
            const currentDirection = getCurrentArrowDirection();
            
            // Check if this is approximately a 180-degree rotation
            const dotProduct = currentDirection.x * targetState.x + 
                            currentDirection.y * targetState.y + 
                            currentDirection.z * targetState.z;
            
            const isNearlyOpposite = Math.abs(dotProduct + 1) < 0.1;
            
            if (isNearlyOpposite) {
                // For 180-degree rotations, choose a rotation axis
                animateArrow180(currentDirection, targetState);
            } else {
                // Normal SLERP animation
                animateArrowSlerp(currentDirection, targetState);
            }
        }

        function animateArrow180(startState, endState) {
            const duration = 1000;
            const startTime = Date.now();
            
            // Choose rotation axis - prefer X-axis, but use Y if start/end are on X-axis
            let rotationAxis;
            if (Math.abs(startState.x) < 0.9) {
                rotationAxis = { x: 1, y: 0, z: 0 }; // Rotate around X-axis
            } else {
                rotationAxis = { x: 0, y: 1, z: 0 }; // Rotate around Y-axis
            }
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const eased = 1 - Math.pow(1 - progress, 3);
                const angle = Math.PI * eased; // 0 to π (180 degrees)
                
                // Rotate startState around the chosen axis
                const currentState = rotateVectorAroundAxis(startState, rotationAxis, angle);
                
                updateArrowDirection(currentState);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }

        function animateArrowSlerp(startState, endState) {
            const duration = 1000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const eased = 1 - Math.pow(1 - progress, 3);
                
                // Spherical linear interpolation
                const currentState = slerp(startState, endState, eased);
                
                updateArrowDirection(currentState);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }

        function slerp(start, end, t) {
            // Normalize vectors
            const startNorm = normalize(start);
            const endNorm = normalize(end);
            
            // Calculate angle between vectors
            const dot = Math.max(-1, Math.min(1, startNorm.x * endNorm.x + startNorm.y * endNorm.y + startNorm.z * endNorm.z));
            const angle = Math.acos(Math.abs(dot));
            
            if (angle < 0.01) {
                // Vectors are very close, use linear interpolation
                return {
                    x: startNorm.x + (endNorm.x - startNorm.x) * t,
                    y: startNorm.y + (endNorm.y - startNorm.y) * t,
                    z: startNorm.z + (endNorm.z - startNorm.z) * t
                };
            }
            
            const sinAngle = Math.sin(angle);
            const startWeight = Math.sin((1 - t) * angle) / sinAngle;
            const endWeight = Math.sin(t * angle) / sinAngle;
            
            return {
                x: startWeight * startNorm.x + endWeight * endNorm.x,
                y: startWeight * startNorm.y + endWeight * endNorm.y,
                z: startWeight * startNorm.z + endWeight * endNorm.z
            };
        }

        function rotateVectorAroundAxis(vector, axis, angle) {
            // Rodrigues' rotation formula
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            const dot = vector.x * axis.x + vector.y * axis.y + vector.z * axis.z;
            const cross = {
                x: axis.y * vector.z - axis.z * vector.y,
                y: axis.z * vector.x - axis.x * vector.z,
                z: axis.x * vector.y - axis.y * vector.x
            };
            
            return {
                x: vector.x * cos + cross.x * sin + axis.x * dot * (1 - cos),
                y: vector.y * cos + cross.y * sin + axis.y * dot * (1 - cos),
                z: vector.z * cos + cross.z * sin + axis.z * dot * (1 - cos)
            };
        }

        function normalize(vector) {
            const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
            return {
                x: vector.x / length,
                y: vector.y / length,
                z: vector.z / length
            };
        }

        function getCurrentArrowDirection() {
            // Extract current direction from the arrow group's rotation
            const matrix = new THREE.Matrix4();
            matrix.makeRotationFromEuler(arrowGroup.rotation);
            const currentDir = new THREE.Vector3(0, 1, 0);
            currentDir.applyMatrix4(matrix);
            
            return {
                x: currentDir.x,
                y: currentDir.y,
                z: currentDir.z
            };
        }

        function updateArrowDirection(direction) {
            const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
            const norm = {
                x: direction.x / length,
                y: direction.y / length,
                z: direction.z / length
            };
            
            const phi = Math.acos(norm.y);
            const theta = Math.atan2(norm.x, norm.z);
            
            arrowGroup.rotation.x = 0;
            arrowGroup.rotation.y = theta;
            arrowGroup.rotation.z = phi;
        }


        // Animation loop
        function animate() {
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            
            sphere.rotation.x = currentRotationX;
            sphere.rotation.y = currentRotationY;
            lineGroup.rotation.x = currentRotationX;
            lineGroup.rotation.y = currentRotationY;
            arrowGroup.rotation.x = currentRotationX;
            arrowGroup.rotation.y = currentRotationY;
            equatorialGroup.rotation.x = currentRotationX;
            equatorialGroup.rotation.y = currentRotationY;
            labelGroup.rotation.x = currentRotationX;
            labelGroup.rotation.y = currentRotationY;
            
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const containerRect = canvasContainer.getBoundingClientRect();
            const canvasWidth = containerRect.width;
            const canvasHeight = containerRect.height;
            
            camera.aspect = canvasWidth / canvasHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        });

        // Welcome message
        addToTerminal('Qiskit Quantum Simulator Ready');
        addToTerminal('Enter your Qiskit code above and click "Run Code" or press Ctrl+Enter');
    </script>
</body>
</html>