<!DOCTYPE html>
<html>
<head>
    <title>Quantum Bit Generator</title>
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-lighter.min.css">
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(135deg, #e8f4fd 0%, #d3cedc 100%);
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
        }
        
        /* Main layout container */
        #main-container {
            display: grid;
            grid-template-columns: var(--left-width, 35%) 4px 1fr;
            grid-template-rows: 100vh;
            height: 100vh;
            width: 100vw;
            min-width: 800px;
        }
        
        /* Left column container */
        #left-container {
            display: grid;
            grid-template-rows: var(--code-height, 50%) 4px 1fr;
            padding: 0px 0 0px 0px;
            gap: 0;
        }
        
        /* Right column container */
        #right-container {
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        
        /* Resize handles */
        .resize-handle {
            background: linear-gradient(135deg, #c8d8f0 0%, #b794f6 100%);
            position: relative;
            transition: background 0.2s ease;
        }
        
        .resize-handle:hover {
            background: linear-gradient(135deg, #b794f6 0%, #8b5cf6 100%);
        }
        
        .resize-handle-vertical {
            cursor: col-resize;
            background: linear-gradient(to right, transparent 1px, #c8d8f0 1px, #b794f6 3px, transparent 3px);
        }
        
        .resize-handle-horizontal {
            cursor: row-resize;
            background: linear-gradient(to bottom, transparent 1px, #c8d8f0 1px, #b794f6 3px, transparent 3px);
        }
        
        /* CodeMirror custom styling */
        .CodeMirror {
            height: 100% !important;
            font-family: 'Courier New', monospace !important;
            font-size: 13px !important;
            border-radius: 8px !important;
            border: 1px solid rgba(214, 231, 255, 0.8) !important;
            background: rgba(255, 255, 255, 0.9) !important;
        }
        
        .CodeMirror-focused .CodeMirror-cursor {
            border-left: 2px solid #5a67d8 !important;
        }
        
        .CodeMirror-selected {
            background: rgba(90, 103, 216, 0.2) !important;
        }
        
        /* Cursor styles */
        body:active {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto;
        }
        canvas { display: block; }
        
        * {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
        }

        .CodeMirror, .CodeMirror * {
            cursor: text !important;
        }

        .CodeMirror-cursor {
            cursor: text !important;
        }

        /* Atom cursor for all elements */
        .panel, .panel-header, .panel-body, .resize-handle {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
        }

        canvas {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
        }
        
        /* Panel styles */
        .panel {
            background: rgba(232, 244, 253, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(138, 143, 244, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            border: 2px solid rgba(200, 216, 240, 0.8);
            min-height: 0;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #d6e7ff 0%, #e1d5f7 100%);
            padding: 12px 18px;
            border-radius: 12px 12px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(200, 216, 240, 0.6);
            box-shadow: 0 2px 8px rgba(138, 143, 244, 0.1);
            flex-shrink: 0;
        }

        .panel-title {
            color: #5a67d8;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }
        
        .panel-subtitle {
            color: #5e4e82;
            font-size: 13px;
            font-weight: 300;
            margin-left: 10px;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .panel-body {
            flex: 1;
            padding: 18px;
            background: linear-gradient(135deg, #f7faff 0%, #faf5ff 100%);
            border-radius: 0 0 12px 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Code panel specific styles */
        #code-container {
            font-family: 'Courier New', monospace;
        }

        #code-input {
            flex: 1;
            min-height: 0;
        }

        #run-button {
            background: linear-gradient(135deg, #8b5cf6 0%, #5a67d8 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
            transition: all 0.2s ease;
            margin-top: 10px;
            flex-shrink: 0;
            width: 100%
        }

        #run-button:hover {
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
        }

        /* Terminal panel specific styles */
        #terminal-container {
            font-family: 'Courier New', monospace;
        }

        #terminal-output {
            flex: 1;
            color: #4a5568;
            font-size: 13px;
            line-height: 1.5;
            overflow-y: auto;
            white-space: pre-wrap;
            background: rgba(255, 255, 255, 0.7);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: inset 0 2px 4px rgba(138, 143, 244, 0.05);
            min-height: 0;
        }

        /* Display panel specific styles */
        #display-container {
            font-family: 'Courier New', monospace;
            flex: 1;
            margin: 0;
            height: 100%;
        }

        #display-body {
            padding: 18px;  /* Keep the padding */
            position: relative;
            overflow: visible;
            height: 100%;
            box-sizing: border-box;
        }

        #canvas-container {
            position: absolute;
            top: 18px;
            left: 18px;
            right: 18px;
            bottom: 18px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: inset 0 2px 4px rgba(138, 143, 244, 0.05);
        }

        #welcome-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #5a67d8;
            font-size: 18px;
            font-weight: 300;
            opacity: 0.7;
        }

        #welcome-message .subtitle {
            font-size: 14px;
            margin-top: 10px;
            color: #8b5cf6;
        }

        .CodeMirror-placeholder {
            color: #a0aec0 !important;
            font-style: italic;
        }

        /* Scrollbar styles */
        #terminal-output::-webkit-scrollbar {
            width: 8px;
        }

        #terminal-output::-webkit-scrollbar-track {
            background: rgba(232, 244, 253, 0.5);
            border-radius: 4px;
        }

        #terminal-output::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #c8d8f0 0%, #b794f6 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #terminal-output::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #b794f6 0%, #8b5cf6 100%);
        }

        /* Multi-qubit grid styles */
        .qubit-grid {
            display: grid;
            gap: 10px;
            padding: 10px;
            height: 100%;
            width: 100%;
            box-sizing: border-box;
            place-items: center;
            overflow: hidden;
        }

        .qubit-grid > div {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        #button-container {
            margin-top: 10px;
            flex-shrink: 0;
            width: 100%;
        }

        #step-buttons {
            display: flex;
            gap: 10px;
        }

        #prev-step-button, #next-step-button {
            flex: 1;
            background: linear-gradient(135deg, #8b5cf6 0%, #5a67d8 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>') 10 10, auto !important; */
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
            transition: all 0.2s ease;
        }

        #prev-step-button:hover:not(:disabled), #next-step-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
        }

        #prev-step-button:disabled, #next-step-button:disabled {
            background: #e2e8f0;
            color: #a0aec0;
            box-shadow: none;
        }


</style>
</head>
<body>
    <div id="main-container">
        <!-- Left container with code editor and terminal -->
        <div id="left-container">
            <!-- Code Input Container -->
            <div id="code-container" class="panel">
                <div class="panel-header">
                    <div class="panel-title">Qiskit Code Editor</div>
                </div>
                <div class="panel-body">
                    <div id="code-input"></div>
                    <div id="button-container">
                        <button id="run-button">▶ Run Code</button>
                        <div id="step-buttons" style="display: none;">
                            <button id="prev-step-button" disabled>◀ Previous Step</button>
                            <button id="next-step-button">Next Step ▶</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Horizontal resize handle -->
            <div class="resize-handle resize-handle-horizontal" id="horizontal-resize"></div>
            
            <!-- Terminal Output Container -->
            <div id="terminal-container" class="panel">
                <div class="panel-header">
                    <div class="panel-title">Output Terminal</div>
                </div>
                <div class="panel-body">
                    <div id="terminal-output"></div>
                </div>
            </div>
        </div>
        
        <!-- Vertical resize handle -->
        <div class="resize-handle resize-handle-vertical" id="vertical-resize"></div>
        
        <!-- Right container with display panel -->
        <div id="right-container">
            <div id="display-container" class="panel">
                <div class="panel-header">
                    <div class="panel-title">Quantum State Visualization
                        <span class="panel-subtitle">(Click and drag on Bloch Spheres to rotate)</span>
                    </div>
                </div>
                <div id="display-body" class="panel-body">
                    <div id="canvas-container">
                        <div id="welcome-message">
                            <div>Welcome to Quantum Visualizer</div>
                            <div class="subtitle">Run quantum code to see Bloch sphere visualization</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Add CodeMirror JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/display/placeholder.min.js"></script>
    
    <script>
        // Resize functionality
        let isResizing = false;
        let currentHandle = null;
        
        // Default layout percentages
        let leftWidth = 35;
        let codeHeight = 50;
        
        // Minimum sizes (in pixels)
        const MIN_LEFT_WIDTH = 300;
        const MIN_RIGHT_WIDTH = 400;
        const MIN_CODE_HEIGHT = 150;
        const MIN_TERMINAL_HEIGHT = 100;
        
        function initializeResizeHandles() {
            const verticalHandle = document.getElementById('vertical-resize');
            const horizontalHandle = document.getElementById('horizontal-resize');
            
            // Vertical resize (between left and right panels)
            verticalHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                currentHandle = 'vertical';
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });
            
            // Horizontal resize (between code editor and terminal)
            horizontalHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                currentHandle = 'horizontal';
                document.body.style.cursor = 'row-resize';
                e.preventDefault();
            });
            
            // Global mouse move handler
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                if (currentHandle === 'vertical') {
                    handleVerticalResize(e);
                } else if (currentHandle === 'horizontal') {
                    handleHorizontalResize(e);
                }
            });
            
            // Global mouse up handler
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    currentHandle = null;
                    document.body.style.cursor = '';
                    
                    // Trigger resize event for Three.js canvases
                    setTimeout(() => {
                        if (currentBlochSpheres.length > 0) {
                            window.dispatchEvent(new Event('resize'));
                        }
                        
                        // Refresh CodeMirror
                        if (codeEditor) {
                            setTimeout(() => codeEditor.refresh(), 100);
                        }
                    }, 100);
                }
            });
        }
        
        function handleVerticalResize(e) {
            const containerWidth = window.innerWidth;
            const newLeftWidth = (e.clientX / containerWidth) * 100;
            
            // Check minimum sizes
            const leftPx = (newLeftWidth / 100) * containerWidth;
            const rightPx = containerWidth - leftPx - 4; // 4px for handle
            
            if (leftPx >= MIN_LEFT_WIDTH && rightPx >= MIN_RIGHT_WIDTH) {
                leftWidth = newLeftWidth;
                updateLayout();
            }
        }
        
        function handleHorizontalResize(e) {
            const leftContainer = document.getElementById('left-container');
            const rect = leftContainer.getBoundingClientRect();
            const containerHeight = rect.height - 4; // 4px for handle
            const relativeY = e.clientY - rect.top;
            const newCodeHeight = (relativeY / containerHeight) * 100;
            
            // Check minimum sizes
            const codePx = (newCodeHeight / 100) * containerHeight;
            const terminalPx = containerHeight - codePx;
            
            if (codePx >= MIN_CODE_HEIGHT && terminalPx >= MIN_TERMINAL_HEIGHT) {
                codeHeight = newCodeHeight;
                updateLayout();
            }
        }
        
        function updateLayout() {
            document.documentElement.style.setProperty('--left-width', leftWidth + '%');
            document.documentElement.style.setProperty('--code-height', codeHeight + '%');
        }
        
        function recreateBlochSpheres() {
            if (!currentGridContainer || currentBlochData.length === 0) return;
            
            const canvasContainer = document.getElementById('canvas-container');
            const containerRect = canvasContainer.getBoundingClientRect();
            const padding = 10;
            
            // Calculate new sphere size
            const availableWidth = (containerRect.width - padding * (currentGridCols + 1)) / currentGridCols;
            const availableHeight = (containerRect.height - padding * (currentGridRows + 1)) / currentGridRows;
            const newSphereSize = Math.min(availableWidth, availableHeight, 1000);
            
            // Clear existing spheres but keep the grid container
            currentBlochSpheres.forEach(sphere => {
                if (sphere.renderer) {
                    sphere.renderer.domElement.parentElement.remove();
                    sphere.renderer.dispose();
                }
            });
            currentBlochSpheres = [];
            
            // Clear grid container children
            while (currentGridContainer.firstChild) {
                currentGridContainer.removeChild(currentGridContainer.firstChild);
            }
            
            // Recreate spheres with new size
            currentBlochData.forEach((qubitData, index) => {
                createSingleBlochSphere(currentGridContainer, qubitData, newSphereSize);
            });
        }

        // Initialize layout on load
        updateLayout();
        initializeResizeHandles();

        // Global variables for multi-qubit support
        let currentBlochSpheres = [];
        let currentGridContainer = null;

        async function runQiskitCode(code) {
            try {
                const response = await fetch('/execute', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ code: code })
                });
                const data = await response.json();
                
                if (data.success) {
                    addToTerminal(`Detected ${data.num_qubits} qubit(s)`);
                    
                    // Start the step-by-step animation
                    startAnimation(data.animation_sequence, data.grid_rows, data.grid_cols);
                    
                } else {
                    addToTerminal(`Error: ${data.error}`, true);
                }
            } catch (error) {
                addToTerminal(`Connection error: ${error.message}`, true);
            }
        }

        // Initialize CodeMirror
        const codeEditor = CodeMirror(document.getElementById('code-input'), {
            mode: 'python',
            theme: 'material-lighter',
            lineNumbers: true,
            indentUnit: 4,
            indentWithTabs: false,
            lineWrapping: true,
            value: ``,
            placeholder: `Enter your Qiskit code here`,
            extraKeys: {
                "Ctrl-Enter": function(cm) {
                    runButton.click();
                }
            }
        });

        // Add change listener to CodeMirror to reset UI when code is edited
        codeEditor.on('change', function(cm, change) {
            // Only reset if we're currently showing step buttons
            if (stepButtons.style.display !== 'none') {
                // Reset to run button
                document.getElementById('run-button').style.display = 'block';
                stepButtons.style.display = 'none';
                
                // Clear animation state
                currentAnimationSequence = null;
                currentStepIndex = -1;
                totalSteps = 0;
                
                // Add a message to terminal
                addToTerminal('Code modified - ready to run new code');
            }
        });

        // Terminal functionality
        const terminalOutput = document.getElementById('terminal-output');
        const runButton = document.getElementById('run-button');

        // Add this after where you get terminalOutput and runButton (around line 700)
        const prevStepButton = document.getElementById('prev-step-button');
        const nextStepButton = document.getElementById('next-step-button');
        const stepButtons = document.getElementById('step-buttons');

        function addToTerminal(text, isError = false) {
            const prefix = `ψ> `;
            const color = isError ? 'color: #e53e3e;' : '';
            terminalOutput.innerHTML += `<span style="${color}">${prefix}${text}</span>\n`;
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        // REPLACE your existing run button click handler with this:
        runButton.addEventListener('click', async () => {
            const code = codeEditor.getValue().trim();
            if (code) {
                // Reset UI to show run button
                document.getElementById('run-button').style.display = 'block';
                stepButtons.style.display = 'none';
                
                addToTerminal(`Executing Qiskit code...`);
                await runQiskitCode(code);
            } else {
                addToTerminal('No code to execute', true);
            }
        });

        // Add these after your existing runButton.addEventListener (around line 720)
        prevStepButton.addEventListener('click', () => {
            if (currentStepIndex > 0 && !isAnimatingStep) {
                animateToPreviousStep();
            }
        });

        nextStepButton.addEventListener('click', () => {
            if (currentStepIndex < totalSteps - 1 && !isAnimatingStep) {
                showStep(currentStepIndex + 1);
            }
        });

        // Add these global variables at the top with the others
        let currentGridRows = 1;
        let currentGridCols = 1;
        let currentBlochData = [];

        let currentAnimationSequence = null;  // Stores all animation steps
        let currentStepIndex = -1;            // Tracks which step we're on
        let totalSteps = 0;                   // Total number of steps

        let isAnimatingStep = false;
        let stepAnimationProgress = {};

        function createMultiQubitVisualization(blochData, gridRows, gridCols) {
            const canvasContainer = document.getElementById('canvas-container');
            const welcomeMessage = document.getElementById('welcome-message');
            
            // Store grid information for resize
            currentGridRows = gridRows;
            currentGridCols = gridCols;
            currentBlochData = blochData;
            
            // Hide welcome message
            if (welcomeMessage) {
                welcomeMessage.style.display = 'none';
            }
            
            // Clear existing visualization
            clearExistingVisualization();
            
            // Create grid container
            const gridContainer = document.createElement('div');
            gridContainer.className = 'qubit-grid';
            gridContainer.style.gridTemplateRows = `repeat(${gridRows}, 1fr)`;
            gridContainer.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
            
            canvasContainer.appendChild(gridContainer);
            currentGridContainer = gridContainer;
            
            // Calculate sphere size based on grid
            const containerRect = canvasContainer.getBoundingClientRect();
            const padding = 10; // Reduced padding
            
            // Calculate available space per cell
            const availableWidth = (containerRect.width - padding * (gridCols + 1)) / gridCols;
            const availableHeight = (containerRect.height - padding * (gridRows + 1)) / gridRows;
            
            // Use the smaller dimension to ensure spheres fit
            const sphereSize = Math.min(availableWidth, availableHeight, 400); // Cap at 400px max
            
            // Add padding to grid
            gridContainer.style.padding = `${padding}px`;
            gridContainer.style.gap = `${padding}px`;
            
           
            // Create Bloch sphere for each qubit
            blochData.forEach((qubitData, index) => {
                createSingleBlochSphere(gridContainer, qubitData, sphereSize);
            });
        }
        function clearExistingVisualization() {
            // Dispose of existing Three.js resources
            currentBlochSpheres.forEach(sphere => {
                if (sphere.renderer) {
                    sphere.renderer.dispose();
                }
                if (sphere.scene) {
                    // Dispose of geometries and materials
                    sphere.scene.traverse((object) => {
                        if (object.geometry) {
                            object.geometry.dispose();
                        }
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(material => material.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                    });
                }
            });
            
            // Clear arrays
            currentBlochSpheres = [];
            
            // Remove grid container
            if (currentGridContainer) {
                currentGridContainer.remove();
                currentGridContainer = null;
            }
        }


        function createSingleBlochSphere(parentContainer, qubitData, maxSize) {
            // Create simple canvas container without box styling
            const canvasDiv = document.createElement('div');
            canvasDiv.style.position = 'relative';
            canvasDiv.style.width = '100%';
            canvasDiv.style.height = '100%';
            canvasDiv.style.overflow = 'visible';
            
            // Calculate font size that scales more slowly
            const baseFontSize = 8; // Minimum font size
            const scaledFontSize = baseFontSize + (maxSize / 50); // Scales much slower
            
            // Add qubit label in upper left corner
            const qubitLabel = document.createElement('div');
            qubitLabel.textContent = qubitData.label;
            qubitLabel.style.position = 'absolute';
            qubitLabel.style.top = '10px';
            qubitLabel.style.left = '10px';
            qubitLabel.style.color = '#8b5cf6';
            qubitLabel.style.fontSize = `${scaledFontSize}px`;
            qubitLabel.style.fontWeight = 'regular';
            qubitLabel.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            qubitLabel.style.zIndex = '1000';
            qubitLabel.style.pointerEvents = 'none';
            
            canvasDiv.appendChild(qubitLabel);
            parentContainer.appendChild(canvasDiv);
            
            // Wait for container to be in DOM, then create Three.js scene
            setTimeout(() => {
                const sphereSize = maxSize;
                const sphereData = createBlochSphereScene(canvasDiv, sphereSize, qubitData.coordinates, qubitData.label);
                currentBlochSpheres.push(sphereData);
            }, 10);
        }

        function createBlochSphereScene(container, size, coordinates, qubitLabel) {
            const baseLabelScale = 0.8; // Minimum label size
            const labelScaleFactor = baseLabelScale + (size / 2000) * 0.1;
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(size, size);
            renderer.setClearColor(0xf8f9fa, 0.1);
            container.appendChild(renderer.domElement);
            
            // Create sphere with enhanced translucent material matching color scheme
            const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xe0e1e3,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);

            // Create a group for the equatorial elements
            const equatorialGroup = new THREE.Group();

            // Create equatorial plane (circular disk) with theme colors
            const planeGeometry = new THREE.CircleGeometry(2, 32);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xc8d8f0,
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const equatorialPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            equatorialPlane.rotation.x = Math.PI / 2;

            // Create X axis with theme color
            const xAxisPoints = [
                new THREE.Vector3(-2, 0, 0),
                new THREE.Vector3(2, 0, 0)
            ];
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPoints);
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0x5a67d8, linewidth: 2 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);

            // Create Y axis with theme color
            const yAxisPoints = [
                new THREE.Vector3(0, 0, -2),
                new THREE.Vector3(0, 0, 2)
            ];
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPoints);
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x5a67d8, linewidth: 2 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);

            // Add plane and axes to the equatorial group
            equatorialGroup.add(equatorialPlane);
            equatorialGroup.add(xAxis);
            equatorialGroup.add(yAxis);
            scene.add(equatorialGroup);

            function createTextTexture(text, color = '#5a67d8') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 256;
                
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                context.fillStyle = color;
                context.font = '40px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'alphabetic';
                context.fillText(text, 256, 168);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.generateMipmaps = false;
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                return texture;
            }
            
            // Create labels
            const oneTexture = createTextTexture('|1⟩', '#5a67d8');
            const oneMaterial = new THREE.SpriteMaterial({ 
                map: oneTexture,
                sizeAttenuation: false,
                transparent: true,
                alphaTest: 0.1
            });
            const oneLabel = new THREE.Sprite(oneMaterial);
            oneLabel.position.set(0, 2.3, 0);
            oneLabel.scale.set(labelScaleFactor, labelScaleFactor * 0.5, 1);

            const zeroTexture = createTextTexture('|0⟩', '#5a67d8');
            const zeroMaterial = new THREE.SpriteMaterial({ 
                map: zeroTexture,
                sizeAttenuation: false,
                transparent: true,
                alphaTest: 0.1
            });
            const zeroLabel = new THREE.Sprite(zeroMaterial);
            zeroLabel.position.set(0, -2.3, 0);
            zeroLabel.scale.set(labelScaleFactor, labelScaleFactor * 0.5, 1);

            const xTexture = createTextTexture('X', '#5a67d8');
            const xMaterial = new THREE.SpriteMaterial({ 
                map: xTexture,
                sizeAttenuation: false,
                transparent: true,
                alphaTest: 0.1
            });
            const xLabel = new THREE.Sprite(xMaterial);
            xLabel.position.set(2.3, 0.1, 0);
            xLabel.scale.set(labelScaleFactor, labelScaleFactor * 0.5, 1);

            const yTexture = createTextTexture('Y', '#5a67d8');
            const yMaterial = new THREE.SpriteMaterial({ 
                map: yTexture,
                sizeAttenuation: false,
                transparent: true,
                alphaTest: 0.1
            });
            const yLabel = new THREE.Sprite(yMaterial);
            yLabel.position.set(0, 0.1, -2.2);
            yLabel.scale.set(labelScaleFactor, labelScaleFactor * 0.5, 1);

            // Add labels to a group (these rotate with the sphere)
            const labelGroup = new THREE.Group();
            labelGroup.add(oneLabel);
            labelGroup.add(zeroLabel);
            labelGroup.add(xLabel);
            labelGroup.add(yLabel);
            scene.add(labelGroup);
            
            // Create arrow components
            const redSphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
            const redSphereMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 });
            const redSphere = new THREE.Mesh(redSphereGeometry, redSphereMaterial);

            const arrowGroup = new THREE.Group();

            const arrowPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 1.95, 0)
            ];
            const arrowGeometry = new THREE.BufferGeometry().setFromPoints(arrowPoints);
            const arrowMaterial = new THREE.LineBasicMaterial({ color: 0x8b5cf6, linewidth: 3 });
            const arrowShaft = new THREE.Line(arrowGeometry, arrowMaterial);

            const coneGeometry = new THREE.ConeGeometry(0.05, 0.15, 20);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 });
            const arrowTip = new THREE.Mesh(coneGeometry, coneMaterial);
            arrowTip.position.y = 1.93;

            arrowGroup.add(arrowShaft);
            arrowGroup.add(arrowTip);
            arrowGroup.add(redSphere);
            scene.add(arrowGroup);

            // Add latitude and longitude lines
            const lineGroup = new THREE.Group();
            
            // Latitude lines
            for (let i = 0; i <= 10; i++) {
                const phi = (i / 10) * Math.PI;
                const points = [];
                for (let j = 0; j <= 64; j++) {
                    const theta = (j / 64) * Math.PI * 2;
                    const x = 2 * Math.sin(phi) * Math.cos(theta);
                    const y = 2 * Math.cos(phi);
                    const z = 2 * Math.sin(phi) * Math.sin(theta);
                    points.push(new THREE.Vector3(x, y, z));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xc8d8f0,
                    opacity: 0.4, 
                    transparent: true 
                });
                const line = new THREE.Line(geometry, material);
                lineGroup.add(line);
            }

            // Longitude lines
            for (let i = 0; i < 12; i++) {
                const theta = (i / 12) * Math.PI * 2;
                const points = [];
                for (let j = 0; j <= 32; j++) {
                    const phi = (j / 32) * Math.PI;
                    const x = 2 * Math.sin(phi) * Math.cos(theta);
                    const y = 2 * Math.cos(phi);
                    const z = 2 * Math.sin(phi) * Math.sin(theta);
                    points.push(new THREE.Vector3(x, y, z));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xc8d8f0,
                    opacity: 0.4, 
                    transparent: true 
                });
                const line = new THREE.Line(geometry, material);
                lineGroup.add(line);
            }

            scene.add(lineGroup);

            // Set initial arrow direction based on coordinates
            updateArrowDirection(arrowGroup, coordinates);

            camera.position.z = 4;

            // Mouse controls for rotation - only when clicking on sphere
            let isMouseDown = false;
            let isRotatingAllowed = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let currentRotationX = 0, currentRotationY = 0;

            // Raycaster for detecting sphere clicks
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function updateMousePosition(event) {
                // Calculate mouse position relative to the canvas
                const canvasRect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
                mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;
            }

            function isClickOnSphere(event) {
                updateMousePosition(event);
                
                // Update the raycaster
                raycaster.setFromCamera(mouse, camera);
                
                // Check for intersections with the sphere
                const intersects = raycaster.intersectObject(sphere);
                
                return intersects.length > 0;
            }

            renderer.domElement.addEventListener('mousedown', (event) => {
                // Only allow rotation if clicking on the sphere
                if (isClickOnSphere(event)) {
                    isMouseDown = true;
                    isRotatingAllowed = true;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
                isRotatingAllowed = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (isMouseDown && isRotatingAllowed) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });

            // Animation loop
            function animate() {
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                sphere.rotation.x = currentRotationX;
                sphere.rotation.y = currentRotationY;
                lineGroup.rotation.x = currentRotationX;
                lineGroup.rotation.y = currentRotationY;
                arrowGroup.rotation.x = currentRotationX;
                arrowGroup.rotation.y = currentRotationY;
                equatorialGroup.rotation.x = currentRotationX;
                equatorialGroup.rotation.y = currentRotationY;
                labelGroup.rotation.x = currentRotationX;
                labelGroup.rotation.y = currentRotationY;
                
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            animate();

            return {
                scene: scene,
                renderer: renderer,
                arrowGroup: arrowGroup,
                animate: animate
            };
        }

        function updateArrowDirection(arrowGroup, coordinates) {
            // Normalize coordinates to unit sphere
            const [x, y, z] = coordinates;
            const length = Math.sqrt(x*x + y*y + z*z) || 1;
            const norm = [x/length, y/length, z/length];
            
            // Convert Bloch coordinates to spherical coordinates
            // Note: Bloch sphere has |0⟩ at north pole (0,0,1) and |1⟩ at south pole (0,0,-1)
            const phi = Math.acos(norm[2]); // polar angle from +z axis
            const theta = Math.atan2(norm[1], norm[0]); // azimuthal angle
            
            // Set arrow rotation
            arrowGroup.rotation.x = 0;
            arrowGroup.rotation.y = theta;
            arrowGroup.rotation.z = phi;
        }

        let currentAnimationTimeout = null;
        let previousCoordinates = {};

        function startAnimation(animationSequence, gridRows, gridCols) {
            // Clear any existing animation timeout
            if (currentAnimationTimeout) {
                clearTimeout(currentAnimationTimeout);
                currentAnimationTimeout = null;
            }
            
            // Store the animation data (no 'let' keywords - use the global variables)
            currentAnimationSequence = animationSequence;
            currentStepIndex = -1;
            totalSteps = animationSequence.length;
            currentGridRows = gridRows;
            currentGridCols = gridCols;
            
            // Hide run button, show step buttons
            document.getElementById('run-button').style.display = 'none';
            stepButtons.style.display = 'flex';
            
            // Reset button states
            prevStepButton.disabled = true;
            nextStepButton.disabled = false;
            
            // Show first step
            showStep(0);
        }

        function showStep(stepIndex) {
            if (stepIndex < 0 || stepIndex >= totalSteps || isAnimatingStep) return;
            
            isAnimatingStep = true;
            currentStepIndex = stepIndex;
            const stepData = currentAnimationSequence[stepIndex];
            
            // Log the current step
            addToTerminal(`Step ${stepData.step}: ${stepData.gate_name}${stepData.target_qubits ? ' on qubit(s) ' + stepData.target_qubits.join(',') : ''}`);
            
            // Update visualization
            if (stepIndex === 0) {
                createMultiQubitVisualization(stepData.bloch_data, currentGridRows, currentGridCols);
                // Print all qubit states for initial step
                stepData.bloch_data.forEach((qubit) => {
                    const coords = qubit.coordinates;
                    addToTerminal(`  ${qubit.label}: x=${coords[0].toFixed(3)}, y=${coords[1].toFixed(3)}, z=${coords[2].toFixed(3)}`);
                });
                isAnimatingStep = false;
            } else {
                animateToNewPositions(stepData.bloch_data);
                // Print only target qubits for subsequent steps
                if (stepData.target_qubits && stepData.target_qubits.length > 0) {
                    stepData.bloch_data.forEach((qubit) => {
                        if (stepData.target_qubits.includes(parseInt(qubit.label.replace('Qubit ', '')))) {
                            const coords = qubit.coordinates;
                            addToTerminal(`  ${qubit.label}: x=${coords[0].toFixed(3)}, y=${coords[1].toFixed(3)}, z=${coords[2].toFixed(3)}`);
                        }
                    });
                }
                // Animation will complete in animateToNewPositions
                setTimeout(() => {
                    isAnimatingStep = false;
                    // Update button states
                    prevStepButton.disabled = (stepIndex === 0);
                    nextStepButton.disabled = (stepIndex === totalSteps - 1);
                }, 1500); // Match animation duration
            }
            
            // If we've reached the last step, show completion message
            if (stepIndex === totalSteps - 1) {
                addToTerminal(`Animation complete!`);
            }
        }

        // Store animation instances
        let animationInstances = [];

        // Modified nextStep function
        function nextStep() {
            if (currentStep < animationSteps.length && !isAnimating) {
                isAnimating = true;
                
                const step = animationSteps[currentStep];
                
                // Create and store the animation instance
                const animation = anime({
                    targets: step.targets,
                    ...step, // spread all properties
                    complete: function() {
                        currentStep++;
                        updateStepIndicator();
                        isAnimating = false;
                    }
                });
                
                // Store this animation instance
                animationInstances[currentStep] = animation;
            }
        }

        function animateToPreviousStep() {
            if (currentStepIndex <= 0 || isAnimatingStep) return;
            
            isAnimatingStep = true;
            
            // Get the current and previous step data
            const currentStep = currentAnimationSequence[currentStepIndex];
            const previousStep = currentAnimationSequence[currentStepIndex - 1];
            
            // Log the reverse animation
            addToTerminal(`Reversing Step ${currentStep.step}: ${currentStep.gate_name}${currentStep.target_qubits ? ' on qubit(s) ' + currentStep.target_qubits.join(',') : ''}`);
            
            // Animate arrows back to previous positions
            currentBlochSpheres.forEach((sphereData, index) => {
                if (index < previousStep.bloch_data.length) {
                    const prevCoords = previousStep.bloch_data[index].coordinates;
                    animateArrowToPosition(sphereData.arrowGroup, prevCoords, () => {
                        // Callback when animation completes
                        if (index === currentBlochSpheres.length - 1) {
                            // Last sphere animation completed
                            currentStepIndex--;
                            isAnimatingStep = false;
                            
                            // Update button states
                            prevStepButton.disabled = (currentStepIndex === 0);
                            nextStepButton.disabled = (currentStepIndex === totalSteps - 1);
                            
                            // Update current data
                            currentBlochData = previousStep.bloch_data;
                        }
                    });
                }
            });
        }


        // Previous step function that reverses the last animation
        function previousStep() {
            if (currentStep > 0 && !isAnimating) {
                isAnimating = true;
                
                // Get the last played animation
                const lastAnimation = animationInstances[currentStep - 1];
                
                if (lastAnimation) {
                    // Set animation direction to reverse and play
                    lastAnimation.reverse();
                    lastAnimation.play();
                    
                    // Use a promise or callback to handle completion
                    lastAnimation.finished.then(() => {
                        currentStep--;
                        updateStepIndicator();
                        isAnimating = false;
                        // Reset the animation direction for potential replay
                        lastAnimation.reverse();
                    });
                }
            }
        }

        // Update your existing animateArrowToPosition function to this:
        function animateArrowToPosition(arrowGroup, targetCoords, onComplete) {
            // Get current rotation
            const startRotationX = arrowGroup.rotation.x;
            const startRotationY = arrowGroup.rotation.y;
            const startRotationZ = arrowGroup.rotation.z;
            
            // Calculate target rotation from coordinates
            const [x, y, z] = targetCoords;
            const length = Math.sqrt(x*x + y*y + z*z) || 1;
            const norm = [x/length, y/length, z/length];
            
            const targetPhi = Math.acos(norm[2]);
            const targetTheta = Math.atan2(norm[1], norm[0]);
            
            const targetRotationX = 0;
            const targetRotationY = targetTheta;
            const targetRotationZ = targetPhi;
            
            // Animate over 1.5 seconds
            const duration = 1500;
            const startTime = Date.now();
            
            function updateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate rotations
                arrowGroup.rotation.x = startRotationX + (targetRotationX - startRotationX) * easeProgress;
                arrowGroup.rotation.y = startRotationY + (targetRotationY - startRotationY) * easeProgress;
                arrowGroup.rotation.z = startRotationZ + (targetRotationZ - startRotationZ) * easeProgress;
                
                if (progress < 1) {
                    requestAnimationFrame(updateRotation);
                } else if (onComplete) {
                    onComplete();  // Call the callback when animation is done
                }
            }
            
            updateRotation();
        }

        // Also update your animateToNewPositions function to handle the callback:
        function animateToNewPositions(newBlochData, onComplete) {
            // Store the new data for potential resizes
            currentBlochData = newBlochData;
            
            let completedAnimations = 0;
            const totalAnimations = currentBlochSpheres.length;
            
            // Update each sphere's arrow to the new position
            currentBlochSpheres.forEach((sphereData, index) => {
                if (index < newBlochData.length) {
                    const newCoords = newBlochData[index].coordinates;
                    animateArrowToPosition(sphereData.arrowGroup, newCoords, () => {
                        completedAnimations++;
                        if (completedAnimations === totalAnimations && onComplete) {
                            onComplete();
                        }
                    });
                }
            });
        }
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (currentBlochSpheres.length > 0 && currentGridContainer) {
                    recreateBlochSpheres();
                }
                
                // Refresh CodeMirror
                if (codeEditor) {
                    codeEditor.refresh();
                }
            }, 250);
        });

        // Welcome message
        addToTerminal('Qiskit Quantum Simulator Ready');
        addToTerminal('Enter your Qiskit code above and click "Run Code" or press Ctrl+Enter');
    </script>
</body>
</html>