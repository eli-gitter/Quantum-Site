        const scene = new THREE.Scene();

        // Calculate canvas dimensions (70% width, positioned right)
        const canvasWidth = window.innerWidth * 0.7;
        const canvasHeight = window.innerHeight;

        const camera = new THREE.PerspectiveCamera(75, canvasWidth/canvasHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(canvasWidth, canvasHeight);
        renderer.setClearColor(0xf8f9fa, 0.1);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.right = '0';
        document.body.appendChild(renderer.domElement);

        // Create sphere with enhanced translucent material matching color scheme
        const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xe0e1e3,
            transparent: true, 
            opacity: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Create a group for the equatorial elements
        const equatorialGroup = new THREE.Group();

        // Create equatorial plane (circular disk) with theme colors
        const planeGeometry = new THREE.CircleGeometry(2, 32);
        const planeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xc8d8f0,
            transparent: true, 
            opacity: 0.2,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const equatorialPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        equatorialPlane.rotation.x = Math.PI / 2;

        // Create X axis with theme color
        const xAxisPoints = [
            new THREE.Vector3(-2, 0, 0),
            new THREE.Vector3(2, 0, 0)
        ];
        const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPoints);
        const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0x5a67d8, linewidth: 2 });
        const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);

        // Create Y axis with theme color
        const yAxisPoints = [
            new THREE.Vector3(0, 0, -2),
            new THREE.Vector3(0, 0, 2)
        ];
        const yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPoints);
        const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x5a67d8, linewidth: 2 });
        const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);

        // Add plane and axes to the equatorial group
        equatorialGroup.add(equatorialPlane);
        equatorialGroup.add(xAxis);
        equatorialGroup.add(yAxis);
        scene.add(equatorialGroup);

        function createTextTexture(text, color = '#5a67d8') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = color;
            context.font = 'bold 40px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'alphabetic';
            context.fillText(text, 256, 168);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        // Create labels
        const oneTexture = createTextTexture('|1⟩', '#5a67d8');
        const oneMaterial = new THREE.SpriteMaterial({ 
            map: oneTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const oneLabel = new THREE.Sprite(oneMaterial);
        oneLabel.position.set(0, 2.3, 0);
        oneLabel.scale.set(0.5, 0.25, 1);

        const zeroTexture = createTextTexture('|0⟩', '#5a67d8');
        const zeroMaterial = new THREE.SpriteMaterial({ 
            map: zeroTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const zeroLabel = new THREE.Sprite(zeroMaterial);
        zeroLabel.position.set(0, -2.10, 0);
        zeroLabel.scale.set(0.5, 0.25, 1);

        const xTexture = createTextTexture('X', '#5a67d8');
        const xMaterial = new THREE.SpriteMaterial({ 
            map: xTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const xLabel = new THREE.Sprite(xMaterial);
        xLabel.position.set(2.2, 0.1, 0);
        xLabel.scale.set(0.5, 0.25, 1);

        const yTexture = createTextTexture('Y', '#5a67d8');
        const yMaterial = new THREE.SpriteMaterial({ 
            map: yTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1
        });
        const yLabel = new THREE.Sprite(yMaterial);
        yLabel.position.set(0, 0.1, -2.2);
        yLabel.scale.set(0.5, 0.25, 1);

        // Add labels to a group
        const labelGroup = new THREE.Group();
        labelGroup.add(oneLabel);
        labelGroup.add(zeroLabel);
        labelGroup.add(xLabel);
        labelGroup.add(yLabel);
        scene.add(labelGroup);

        // Create arrow components
        const redSphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
        const redSphereMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 });
        const redSphere = new THREE.Mesh(redSphereGeometry, redSphereMaterial);

        const arrowGroup = new THREE.Group();

        const arrowPoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 1.95, 0)
        ];
        const arrowGeometry = new THREE.BufferGeometry().setFromPoints(arrowPoints);
        const arrowMaterial = new THREE.LineBasicMaterial({ color: 0x8b5cf6, linewidth: 3 });
        const arrowShaft = new THREE.Line(arrowGeometry, arrowMaterial);

        const coneGeometry = new THREE.ConeGeometry(0.05, 0.15, 20);
        const coneMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 });
        const arrowTip = new THREE.Mesh(coneGeometry, coneMaterial);
        arrowTip.position.y = 1.93;

        arrowGroup.add(arrowShaft);
        arrowGroup.add(arrowTip);
        arrowGroup.add(redSphere);
        scene.add(arrowGroup);

        // Add latitude and longitude lines
        const lineGroup = new THREE.Group();
        
        // Latitude lines
        for (let i = 0; i <= 10; i++) {
            const phi = (i / 10) * Math.PI;
            const points = [];
            for (let j = 0; j <= 64; j++) {
                const theta = (j / 64) * Math.PI * 2;
                const x = 2 * Math.sin(phi) * Math.cos(theta);
                const y = 2 * Math.cos(phi);
                const z = 2 * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xc8d8f0,
                opacity: 0.4, 
                transparent: true 
            });
            const line = new THREE.Line(geometry, material);
            lineGroup.add(line);
        }

        // Longitude lines
        for (let i = 0; i < 12; i++) {
            const theta = (i / 12) * Math.PI * 2;
            const points = [];
            for (let j = 0; j <= 32; j++) {
                const phi = (j / 32) * Math.PI;
                const x = 2 * Math.sin(phi) * Math.cos(theta);
                const y = 2 * Math.cos(phi);
                const z = 2 * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xc8d8f0,
                opacity: 0.4, 
                transparent: true 
            });
            const line = new THREE.Line(geometry, material);
            lineGroup.add(line);
        }

        scene.add(lineGroup);
        camera.position.z = 5;

    // Mouse controls for rotation - only when clicking on sphere
    let isMouseDown = false;
    let isRotatingAllowed = false;
    let mouseX = 0, mouseY = 0;
    let targetRotationX = 0, targetRotationY = 0;
    let currentRotationX = 0, currentRotationY = 0;

    // Raycaster for detecting sphere clicks
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function updateMousePosition(event) {
        // Calculate mouse position relative to the canvas
        const canvasRect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
        mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;
    }

    function isClickOnSphere(event) {
        updateMousePosition(event);
        
        // Update the raycaster
        raycaster.setFromCamera(mouse, camera);
        
        // Check for intersections with the sphere
        const intersects = raycaster.intersectObject(sphere);
        
        return intersects.length > 0;
    }

    document.addEventListener('mousedown', (event) => {
        // Only allow rotation if clicking on the sphere
        if (isClickOnSphere(event)) {
            isMouseDown = true;
            isRotatingAllowed = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
            
            // Optional: Change cursor to indicate dragging
            document.body.style.cursor = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="2"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="2"/></svg>\') 10 10, auto';
        }
    });

    document.addEventListener('mouseup', () => {
        isMouseDown = false;
        isRotatingAllowed = false;
        
        // Reset cursor
        document.body.style.cursor = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="%23b794f6"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="%235a67d8" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="%235a67d8" stroke-width="1"/></svg>\') 10 10, auto';
    });

    document.addEventListener('mousemove', (event) => {
        if (isMouseDown && isRotatingAllowed) {
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            targetRotationY += deltaX * 0.01;
            targetRotationX += deltaY * 0.01;
            
            targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
    });

    // Update touch controls similarly
    let touchX = 0, touchY = 0;
    let isTouchRotatingAllowed = false;

    function isTouchOnSphere(event) {
        if (event.touches.length !== 1) return false;
        
        const canvasRect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.touches[0].clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
        mouse.y = -((event.touches[0].clientY - canvasRect.top) / canvasRect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(sphere);
        
        return intersects.length > 0;
    }

    function handleTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1 && isTouchOnSphere(event)) {
            isTouchRotatingAllowed = true;
            touchX = event.touches[0].clientX;
            touchY = event.touches[0].clientY;
        }
    }

    function handleTouchMove(event) {
        event.preventDefault();
        if (event.touches.length === 1 && isTouchRotatingAllowed) {
            const deltaX = event.touches[0].clientX - touchX;
            const deltaY = event.touches[0].clientY - touchY;
            
            targetRotationY += deltaX * 0.01;
            targetRotationX += deltaY * 0.01;
            
            targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
            
            touchX = event.touches[0].clientX;
            touchY = event.touches[0].clientY;
        }
    }

    function handleTouchEnd(event) {
        event.preventDefault();
        isTouchRotatingAllowed = false;
    }

    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Animation loop
        function animate() {
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            
            sphere.rotation.x = currentRotationX;
            sphere.rotation.y = currentRotationY;
            lineGroup.rotation.x = currentRotationX;
            lineGroup.rotation.y = currentRotationY;
            arrowGroup.rotation.x = currentRotationX;
            arrowGroup.rotation.y = currentRotationY;
            equatorialGroup.rotation.x = currentRotationX;
            equatorialGroup.rotation.y = currentRotationY;
            labelGroup.rotation.x = currentRotationX;
            labelGroup.rotation.y = currentRotationY;
            
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const canvasWidth = window.innerWidth * 0.7;
            const canvasHeight = window.innerHeight;
            
            camera.aspect = canvasWidth / canvasHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        });





        



                // Animation functions
        function animateArrowTo(targetState) {
            const duration = 1000;
            const startTime = Date.now();
            const startState = { x: 0, y: 1, z: 0 };
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const eased = 1 - Math.pow(1 - progress, 3);
                
                const newState = {
                    x: startState.x + (targetState.x - startState.x) * eased,
                    y: startState.y + (targetState.y - startState.y) * eased,
                    z: startState.z + (targetState.z - startState.z) * eased
                };
                
                updateArrowDirection(newState);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }

        function updateArrowDirection(direction) {
            const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
            const norm = {
                x: direction.x / length,
                y: direction.y / length,
                z: direction.z / length
            };
            
            const phi = Math.acos(norm.y);
            const theta = Math.atan2(norm.x, norm.z);
            
            arrowGroup.rotation.x = 0;
            arrowGroup.rotation.y = theta;
            arrowGroup.rotation.z = phi;
        }