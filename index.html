<!DOCTYPE html>
<html>
<head>
    <title>Quantum Bit Generator</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="red"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="blue" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="blue" stroke-width="1"/></svg>') 10 10, auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body:active {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="2" fill="red"/><ellipse cx="10" cy="10" rx="8" ry="3" fill="none" stroke="blue" stroke-width="1"/><ellipse cx="10" cy="10" rx="3" ry="8" fill="none" stroke="blue" stroke-width="1"/></svg>') 10 10, auto;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Scene, camera, renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xf8f9fa);
        document.body.appendChild(renderer.domElement);

        // Create sphere with translucent grey material
        const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xcccccc, 
            transparent: true, 
            opacity: 0.4,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // Create a group for the equatorial elements
        const equatorialGroup = new THREE.Group();

        // Create equatorial plane (circular disk)
        const planeGeometry = new THREE.CircleGeometry(2, 32);
        const planeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x888888, 
            transparent: true, 
            opacity: 0.2,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const equatorialPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        equatorialPlane.rotation.x = Math.PI / 2; // Rotate to lie flat (horizontal)

        // Create X axis (red line)
        const xAxisPoints = [
            new THREE.Vector3(-2, 0, 0),
            new THREE.Vector3(2, 0, 0)
        ];
        const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPoints);
        const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);

        // Create Y axis (green line)
        const yAxisPoints = [
            new THREE.Vector3(0, 0, -2),
            new THREE.Vector3(0, 0, 2)
        ];
        const yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPoints);
        const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);

        // Add plane and axes to the equatorial group
        equatorialGroup.add(equatorialPlane);
        equatorialGroup.add(xAxis);
        equatorialGroup.add(yAxis);
        scene.add(equatorialGroup);

        function createTextTexture(text, color = '#000000') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;  // Much larger canvas
            canvas.height = 256; // Much larger canvas
            
            // Explicitly clear the canvas to be fully transparent
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = color;
            context.font = '40px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif';            context.textAlign = 'center';
            context.textBaseline = 'alphabetic';
            context.fillText(text, 256, 168);  // Centered in larger canvas
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        // Create |1⟩ label at top
        const oneTexture = createTextTexture('|1⟩', '#000000');
        const oneMaterial = new THREE.SpriteMaterial({ 
            map: oneTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1  // This will make fully transparent pixels invisible
        });
        const oneLabel = new THREE.Sprite(oneMaterial);
        oneLabel.position.set(0, 2.3, 0);
        oneLabel.scale.set(0.5, 0.25, 1);

        // Create |0⟩ label at bottom
        const zeroTexture = createTextTexture('|0⟩', '#000000');
        const zeroMaterial = new THREE.SpriteMaterial({ 
            map: zeroTexture,
            sizeAttenuation: false,
            transparent: true,
            alphaTest: 0.1  // This will make fully transparent pixels invisible
        });
        const zeroLabel = new THREE.Sprite(zeroMaterial);
        zeroLabel.position.set(0, -2.10, 0);
        zeroLabel.scale.set(0.5, 0.25, 1);


        // Add labels to a group so they rotate with the sphere
        const labelGroup = new THREE.Group();
        labelGroup.add(oneLabel);
        labelGroup.add(zeroLabel);
        scene.add(labelGroup);

        // Create smaller red sphere at center
        const redSphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
        const redSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const redSphere = new THREE.Mesh(redSphereGeometry, redSphereMaterial);

        // Create arrow group to keep shaft and tip together
        const arrowGroup = new THREE.Group();

        // Create arrow shaft
        const arrowPoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 1.95, 0)
        ];
        const arrowGeometry = new THREE.BufferGeometry().setFromPoints(arrowPoints);
        const arrowMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
        const arrowShaft = new THREE.Line(arrowGeometry, arrowMaterial);

        // Create arrow cone tip
        const coneGeometry = new THREE.ConeGeometry(0.05, 0.15, 20);
        const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const arrowTip = new THREE.Mesh(coneGeometry, coneMaterial);
        arrowTip.position.y = 1.93;

        // Add components to arrow group
        arrowGroup.add(arrowShaft);
        arrowGroup.add(arrowTip);
        arrowGroup.add(redSphere);
        scene.add(arrowGroup);

        // Add latitude and longitude lines
        const lineGroup = new THREE.Group();
        
        // Latitude lines
        for (let i = 0; i <= 10; i++) {
            const phi = (i / 10) * Math.PI;
            const points = [];
            for (let j = 0; j <= 64; j++) {
                const theta = (j / 64) * Math.PI * 2;
                const x = 2 * Math.sin(phi) * Math.cos(theta);
                const y = 2 * Math.cos(phi);
                const z = 2 * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x999999, 
                opacity: 0.4, 
                transparent: true 
            });
            const line = new THREE.Line(geometry, material);
            lineGroup.add(line);
        }

        // Longitude lines
        for (let i = 0; i < 12; i++) {
            const theta = (i / 12) * Math.PI * 2;
            const points = [];
            for (let j = 0; j <= 32; j++) {
                const phi = (j / 32) * Math.PI;
                const x = 2 * Math.sin(phi) * Math.cos(theta);
                const y = 2 * Math.cos(phi);
                const z = 2 * Math.sin(phi) * Math.sin(theta);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x999999, 
                opacity: 0.4, 
                transparent: true 
            });
            const line = new THREE.Line(geometry, material);
            lineGroup.add(line);
        }

        scene.add(lineGroup);
        camera.position.z = 5;

        // Mouse controls for rotation
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        // Animation loop
        function animate() {
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            
            sphere.rotation.x = currentRotationX;
            sphere.rotation.y = currentRotationY;
            lineGroup.rotation.x = currentRotationX;
            lineGroup.rotation.y = currentRotationY;
            arrowGroup.rotation.x = currentRotationX;
            arrowGroup.rotation.y = currentRotationY;
            equatorialGroup.rotation.x = currentRotationX;
            equatorialGroup.rotation.y = currentRotationY;
            labelGroup.rotation.x = currentRotationX;
            labelGroup.rotation.y = currentRotationY;
            
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>